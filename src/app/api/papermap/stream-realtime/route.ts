import { GoogleGenerativeAI } from '@google/generative-ai';
import { NextRequest } from 'next/server';
import { db } from '@/db';
import { mindmaps, mindmapNodes } from '@/db/schema';
import { v4 as uuidv4 } from 'uuid';
import { eq } from 'drizzle-orm';
import { z } from 'zod';

// Initialize Google AI services
const genAI = new GoogleGenerativeAI(process.env.GOOGLE_GENERATIVE_AI_API_KEY || '');

// Zod schema for validating individual nodes
const NodeSchema = z.object({
    id: z.string(),
    title: z.string(),
    description: z.string().optional().default(''),
    parentId: z.string().nullable(),
    level: z.number(),
    pageNumber: z.number().nullable().optional(),
});

// NDJSON Prompt - generates one node per line for real-time streaming
const NDJSON_PROMPT = `You are a mindmap generator that outputs nodes in NDJSON format (one JSON object per line).

OUTPUT FORMAT (CRITICALLY IMPORTANT):
- Output EXACTLY ONE valid JSON object per line
- Each line is a complete, self-contained node
- NO wrapping object, NO "nodes" array - just individual node objects
- NO trailing commas, NO extra text, NO markdown code blocks

STRUCTURE:
Line 1: {"id":"node_1","title":"Root Title","description":"Root description","parentId":null,"level":0,"pageNumber":1}
Line 2: {"id":"node_2","title":"Main Topic 1","description":"Brief description","parentId":"node_1","level":1,"pageNumber":1}
Line 3: {"id":"node_3","title":"Main Topic 2","description":"Brief description","parentId":"node_1","level":1,"pageNumber":2}
... and so on

RULES:
1. First line MUST be the root node (level=0, parentId=null)
2. Use level=1 for main topics, level=2 for subtopics
3. Every node's parentId must reference an existing node's id
4. Use unique IDs like "node_1", "node_2", etc.
5. Keep descriptions concise (1-2 sentences)
6. Use **bold** and *italics* in descriptions
7. Include pageNumber when applicable (for PDFs)
8. Generate 8-15 nodes total for a comprehensive mindmap

START OUTPUT IMMEDIATELY with the root node. No preamble.`;

interface StreamMessage {
    type: 'node' | 'complete' | 'error' | 'init';
    node?: z.infer<typeof NodeSchema>;
    mindmapId?: string;
    error?: string;
}

function createSSEMessage(data: StreamMessage): string {
    return `data: ${JSON.stringify(data)}\n\n`;
}

/**
 * True streaming API endpoint using NDJSON format
 * Streams individual nodes as they're generated by the AI
 */
export async function POST(request: NextRequest) {
    // Verify Gemini API key is configured
    if (!process.env.GOOGLE_GENERATIVE_AI_API_KEY) {
        return new Response(
            createSSEMessage({ type: 'error', error: 'GOOGLE_GENERATIVE_AI_API_KEY is not configured' }),
            {
                status: 500,
                headers: {
                    'Content-Type': 'text/event-stream',
                    'Cache-Control': 'no-cache',
                    'Connection': 'keep-alive',
                }
            }
        );
    }

    const encoder = new TextEncoder();
    const stream = new TransformStream();
    const writer = stream.writable.getWriter();

    // Start processing in the background
    (async () => {
        const mindmapId = uuidv4();
        const allNodes: z.infer<typeof NodeSchema>[] = [];
        let buffer = '';

        try {
            const data = await request.json();
            const { blobUrl, textInput, sourceUrl, originalFileName } = data;

            // Initialize Gemini API with streaming-compatible config
            // Note: responseMimeType must NOT be set for streaming with NDJSON
            const model = genAI.getGenerativeModel({
                model: "gemini-2.5-flash",
                generationConfig: {
                    temperature: 0.7,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 8192,
                    // DO NOT set responseMimeType for streaming - we handle JSON ourselves
                }
            });

            // Determine input type
            let inputType: 'pdf' | 'text' | 'url' = 'text';
            if (blobUrl && !textInput) {
                inputType = originalFileName ? 'pdf' : 'url';
            } else if (textInput && sourceUrl) {
                inputType = 'url';
            }

            // Build the prompt based on input type
            let fullPrompt: string;
            let messageParts: any[] = [];

            if (textInput && sourceUrl) {
                fullPrompt = `${NDJSON_PROMPT}

Create a mindmap for this web content:
"${textInput.substring(0, 8000)}"

Source URL: ${sourceUrl}

Generate nodes NOW (one JSON per line, starting with root):`;
                messageParts = [{ text: fullPrompt }];
            } else if (textInput) {
                fullPrompt = `${NDJSON_PROMPT}

Create a mindmap for this topic or question:
"${textInput}"

Generate nodes NOW (one JSON per line, starting with root):`;
                messageParts = [{ text: fullPrompt }];
            } else if (blobUrl) {
                fullPrompt = `${NDJSON_PROMPT}

Analyze this PDF and create a comprehensive mindmap.
Include page numbers for each node where the content is found.

Generate nodes NOW (one JSON per line, starting with root):`;

                if (blobUrl.includes('vercel-blob.com')) {
                    messageParts = [
                        { text: fullPrompt },
                        { fileData: { mimeType: "application/pdf", fileUri: blobUrl } }
                    ];
                } else {
                    // Fetch and convert to base64 for non-Vercel URLs
                    const pdfResponse = await fetch(blobUrl);
                    if (!pdfResponse.ok) {
                        throw new Error(`Failed to download PDF: ${pdfResponse.status}`);
                    }
                    const pdfBuffer = await pdfResponse.arrayBuffer();
                    const base64Data = Buffer.from(pdfBuffer).toString('base64');
                    messageParts = [
                        { text: fullPrompt },
                        { inlineData: { mimeType: "application/pdf", data: base64Data } }
                    ];
                }
            } else {
                throw new Error('No valid input provided');
            }

            // Create mindmap record first (without title, will update later)
            const now = new Date();
            await db.insert(mindmaps).values({
                id: mindmapId,
                title: 'Generating...',
                inputType,
                pdfUrl: blobUrl || null,
                fileName: originalFileName || 'mindmap',
                sourceUrl: sourceUrl || null,
                createdAt: now,
                updatedAt: now,
            });

            // Send init message with mindmapId
            await writer.write(encoder.encode(createSSEMessage({
                type: 'init',
                mindmapId
            })));

            // Use streaming API
            const result = await model.generateContentStream(messageParts);

            // Process the stream chunk by chunk
            for await (const chunk of result.stream) {
                const text = chunk.text();
                buffer += text;

                // Try to extract complete JSON lines from buffer
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // Keep incomplete line in buffer

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine) continue;

                    // Skip common non-JSON lines
                    if (trimmedLine.startsWith('```') ||
                        trimmedLine.startsWith('Here') ||
                        trimmedLine.startsWith('The following') ||
                        !trimmedLine.startsWith('{')) {
                        continue;
                    }

                    try {
                        // Parse the JSON line
                        const nodeData = JSON.parse(trimmedLine);

                        // Validate with Zod
                        const validatedNode = NodeSchema.parse(nodeData);

                        // Add to our collection
                        allNodes.push(validatedNode);

                        // Save node to database immediately
                        await db.insert(mindmapNodes).values({
                            mindmapId,
                            nodeId: validatedNode.id,
                            title: validatedNode.title,
                            description: validatedNode.description || '',
                            parentId: validatedNode.parentId,
                            level: validatedNode.level,
                            pageNumber: validatedNode.pageNumber ?? null,
                        });

                        // Stream node to client
                        await writer.write(encoder.encode(createSSEMessage({
                            type: 'node',
                            node: validatedNode
                        })));

                        // Update title from root node
                        if (validatedNode.level === 0 && validatedNode.parentId === null) {
                            await db.update(mindmaps)
                                .set({ title: validatedNode.title, updatedAt: new Date() })
                                .where(eq(mindmaps.id, mindmapId));
                        }
                    } catch (parseError) {
                        // Skip invalid lines but log for debugging
                        console.warn('Failed to parse node line:', trimmedLine.substring(0, 100), parseError);
                    }
                }
            }

            // Process any remaining buffer content
            if (buffer.trim()) {
                const trimmedBuffer = buffer.trim();
                if (trimmedBuffer.startsWith('{') && trimmedBuffer.endsWith('}')) {
                    try {
                        const nodeData = JSON.parse(trimmedBuffer);
                        const validatedNode = NodeSchema.parse(nodeData);
                        allNodes.push(validatedNode);

                        await db.insert(mindmapNodes).values({
                            mindmapId,
                            nodeId: validatedNode.id,
                            title: validatedNode.title,
                            description: validatedNode.description || '',
                            parentId: validatedNode.parentId,
                            level: validatedNode.level,
                            pageNumber: validatedNode.pageNumber ?? null,
                        });

                        await writer.write(encoder.encode(createSSEMessage({
                            type: 'node',
                            node: validatedNode
                        })));
                    } catch (e) {
                        console.warn('Failed to parse final buffer:', trimmedBuffer.substring(0, 100));
                    }
                }
            }

            // Send completion message
            await writer.write(encoder.encode(createSSEMessage({
                type: 'complete',
                mindmapId
            })));

            // Fire-and-forget: Fetch Jina content for PDF
            if (blobUrl && (inputType === 'pdf' || inputType === 'url')) {
                fetchPdfMarkdownAndUpdateDb(mindmapId, blobUrl).catch(err => {
                    console.error('[Background] Jina fetch failed:', err);
                });
            }

        } catch (error) {
            console.error('True streaming error:', error);

            // Clean up failed mindmap if no nodes were saved
            if (allNodes.length === 0) {
                try {
                    await db.delete(mindmaps).where(eq(mindmaps.id, mindmapId));
                } catch (e) {
                    console.error('Failed to clean up mindmap:', e);
                }
            }

            await writer.write(encoder.encode(createSSEMessage({
                type: 'error',
                error: error instanceof Error ? error.message : 'Unknown error occurred'
            })));
        } finally {
            await writer.close();
        }
    })();

    return new Response(stream.readable, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
        },
    });
}

// Helper function to fetch PDF markdown from Jina
async function fetchPdfMarkdownAndUpdateDb(mindmapId: string, pdfUrl: string) {
    try {
        const jinaReaderApiUrl = `https://r.jina.ai/${encodeURIComponent(pdfUrl)}`;
        console.log(`[Background] Fetching PDF content from Jina Reader for mindmap ${mindmapId}`);

        const jinaResponse = await fetch(jinaReaderApiUrl, {
            headers: { "Accept": "text/markdown, text/plain;q=0.9, */*;q=0.8" }
        });

        if (jinaResponse.ok) {
            const parsedPdfMarkdown = await jinaResponse.text();
            const sanitizedMarkdown = parsedPdfMarkdown.replace(/\0/g, '');

            await db.update(mindmaps)
                .set({ parsed_pdf_content: sanitizedMarkdown, updatedAt: new Date() })
                .where(eq(mindmaps.id, mindmapId));

            console.log(`[Background] Successfully updated mindmap ${mindmapId} with parsed PDF content.`);
        } else {
            console.warn(`[Background] Jina Reader failed for mindmap ${mindmapId}: ${jinaResponse.status}`);
        }
    } catch (jinaError: any) {
        console.error(`[Background] Jina error for mindmap ${mindmapId}:`, jinaError.message);
    }
}
